# アーキテクチャ設計書

## 1. 軽量版クリーンアーキテクチャ採用

### 1.1 アーキテクチャ概要

```
┌─────────────────────────────────────────┐
│               UI Layer                  │
│           (Edge Functions)              │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│           Application Layer             │
│              (Services)                 │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│            Domain Layer                 │
│         (Entities + Interfaces)         │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│          Infrastructure Layer           │
│     (Repositories + External APIs)      │
└─────────────────────────────────────────┘
```

### 1.2 ディレクトリ構造

```
src/
├── domain/                    # ドメイン層
│   ├── entities/             # ビジネスエンティティ（Class）
│   │   ├── Ticket.ts         # チケットエンティティ + ビジネスロジック
│   │   ├── NotificationHistory.ts
│   │   ├── Database.ts       # DB型定義
│   │   ├── index.ts
│   │   └── __tests__/        # エンティティ単体テスト
│   └── interfaces/           # リポジトリインターフェース
│       ├── TicketRepository.ts
│       └── NotificationRepository.ts
├── infrastructure/           # インフラ層
│   ├── repositories/         # リポジトリ実装
│   │   ├── TicketRepositoryImpl.ts    # 技術非依存命名
│   │   ├── NotificationRepositoryImpl.ts
│   │   ├── converters/       # DB↔Domain変換
│   │   └── __tests__/        # リポジトリ単体テスト
│   └── utils/                # インフラ共通処理
├── application/              # アプリケーション層
│   └── services/             # ユースケース実装
└── functions/                # UI層（Edge Functions）
```

## 2. ドメインエンティティ設計（Class化）

### 2.1 設計方針

**❌ 従来のInterface（データ入れ物）**
```typescript
export interface Ticket {
  id: string;
  matchName: string;
  // ただのデータ構造
}
```

**✅ Class化（リッチドメインモデル）**
```typescript
export class Ticket {
  private readonly props: TicketProps;
  
  constructor(props: TicketProps) {
    this.validateTicketData(props);  // バリデーション
    this.props = { ...props };       // イミュータビリティ
  }
  
  // ビジネスロジック集約
  shouldSendNotification(type: NotificationType): boolean
  isOnSale(): boolean
  isValidForNotification(): boolean
}
```

### 2.2 Ticketエンティティ

```typescript
export class Ticket {
  // ✅ 通知タイミング判定ビジネスロジック
  shouldSendNotification(type: NotificationType, currentTime: Date = new Date()): boolean {
    switch (type) {
      case 'day_before':
        return this.shouldSendDayBeforeNotification(currentTime);
      case 'hour_before': 
        return this.shouldSendHourBeforeNotification(currentTime);
      case 'minutes_before':
        return this.shouldSendMinutesBeforeNotification(currentTime);
    }
  }

  // ✅ 前日20:00通知判定（5分の幅）
  private shouldSendDayBeforeNotification(currentTime: Date): boolean {
    const dayBefore = new Date(this.props.saleStartDate);
    dayBefore.setDate(dayBefore.getDate() - 1);
    dayBefore.setHours(20, 0, 0, 0);
    const timeDiff = Math.abs(currentTime.getTime() - dayBefore.getTime());
    return timeDiff <= 5 * 60 * 1000; // 5分以内
  }

  // ✅ 販売状態判定
  isOnSale(currentTime: Date = new Date()): boolean {
    return currentTime >= this.props.saleStartDate && this.isValidTicket();
  }

  // ✅ 通知対象判定
  isValidForNotification(): boolean {
    const now = new Date();
    if (this.props.matchDate <= now) return false; // 過去の試合
    if (now.getTime() > this.props.saleStartDate.getTime() + 24 * 60 * 60 * 1000) {
      return false; // 販売開始から1日経過
    }
    return this.isValidTicket();
  }

  // ✅ データバリデーション
  private validateTicketData(props: TicketProps): void {
    if (!props.id || props.id.trim() === '') {
      throw new Error('Ticket ID is required');
    }
    if (props.matchDate <= props.saleStartDate) {
      throw new Error('Match date must be after sale start date');
    }
    if (!this.isValidUrl(props.ticketUrl)) {
      throw new Error('Valid ticket URL is required');
    }
    // 他のバリデーションルール...
  }
}
```

### 2.3 NotificationHistoryエンティティ

```typescript
export class NotificationHistory {
  // ✅ 送信可能性判定
  canBeSent(currentTime: Date = new Date()): boolean {
    if (this.props.status !== 'pending') return false;
    const timeDiff = this.props.scheduledAt.getTime() - currentTime.getTime();
    return timeDiff <= 5 * 60 * 1000; // 5分前から送信可能
  }

  // ✅ 期限切れ判定
  isExpired(currentTime: Date = new Date()): boolean {
    const timeDiff = currentTime.getTime() - this.props.scheduledAt.getTime();
    return this.props.status === 'pending' && timeDiff > 60 * 60 * 1000; // 1時間
  }

  // ✅ リトライ可能性判定
  canRetry(currentTime: Date = new Date()): boolean {
    if (this.props.status !== 'failed') return false;
    if (this.isExpired(currentTime)) return false;
    const sentAt = this.props.sentAt || this.props.createdAt;
    const timeSinceFailure = currentTime.getTime() - sentAt.getTime();
    return timeSinceFailure >= 5 * 60 * 1000; // 5分後からリトライ可能
  }

  // ✅ イミュータブルな状態変更
  markAsSent(sentTime: Date = new Date()): NotificationHistory {
    return new NotificationHistory({
      ...this.props,
      status: 'sent',
      sentAt: sentTime,
      errorMessage: undefined
    });
  }

  markAsFailed(errorMessage: string, failedTime: Date = new Date()): NotificationHistory {
    return new NotificationHistory({
      ...this.props,
      status: 'failed',
      sentAt: failedTime,
      errorMessage
    });
  }
}
```

## 3. リポジトリ層設計

### 3.1 命名規則改善

**❌ 技術依存命名**
```typescript
export class SupabaseTicketRepository implements TicketRepository
```

**✅ 技術非依存命名**
```typescript
export class TicketRepositoryImpl implements TicketRepository
```

### 3.2 Converter設計

```typescript
export class TicketConverter {
  // DB Row → Domain Entity
  static toDomainEntity(data: TicketRow): Ticket {
    return new Ticket({  // ✅ Class インスタンス生成
      id: data.id,
      matchName: data.match_name,
      matchDate: new Date(data.match_date),
      // snake_case → camelCase変換
    });
  }

  // Domain Entity → DB Insert
  static toDatabaseRow(ticket: Ticket): TicketInsert {
    const plainObject = ticket.toPlainObject();  // ✅ Class → Plain Object
    return {
      id: plainObject.id,
      match_name: plainObject.matchName,  // camelCase → snake_case変換
      match_date: plainObject.matchDate.toISOString(),
    };
  }
}
```

## 4. テスト戦略

### 4.1 テスト階層

```
├── エンティティ単体テスト
│   ├── src/domain/entities/__tests__/Ticket.test.ts (8ケース)
│   └── src/domain/entities/__tests__/NotificationHistory.test.ts (11ケース)
├── リポジトリ単体テスト  
│   ├── src/infrastructure/repositories/__tests__/TicketRepositoryImpl.test.ts
│   └── src/infrastructure/repositories/__tests__/NotificationRepositoryImpl.test.ts
└── 統合テスト
    └── tests/integration/repository.test.ts (9ケース)
```

### 4.2 テスト内容

#### エンティティビジネスロジックテスト
```typescript
// 通知タイミング判定テスト
"Ticket - 通知タイミング判定: 前日20:00通知"
"Ticket - 通知タイミング判定: 1時間前通知" 
"Ticket - 通知タイミング判定: 15分前通知"

// バリデーションテスト
"Ticket - バリデーション: 空のID"
"Ticket - バリデーション: 不正なURL"
"Ticket - バリデーション: 試合日が販売開始日より前"

// 状態管理テスト
"NotificationHistory - 送信可能性判定"
"NotificationHistory - 期限切れ判定"
"NotificationHistory - リトライ可能性判定"
"NotificationHistory - 送信完了マーク"
"NotificationHistory - 送信失敗マーク"
```

### 4.3 セキュリティ強化

```json
// deno.json
{
  "tasks": {
    "test": "deno test --allow-env --allow-net=127.0.0.1 --coverage=coverage",
    //  ❌ --allow-all → ✅ 最小権限
    "test:unit": "deno test src/ --coverage=coverage",
    "test:integration": "deno test tests/integration/ --allow-env --allow-net=127.0.0.1"
  }
}
```

## 5. 利点と効果

### 5.1 Class化による効果

| 観点 | Before (Interface) | After (Class) | 効果 |
|------|-------------------|--------------|------|
| **ビジネスロジック** | 分散 | エンティティに集約 | 保守性向上 |
| **データ整合性** | 外部バリデーション | コンストラクタ保証 | バグ削減 |
| **不変性** | 保証なし | readonly props | 予期しない変更防止 |
| **テスタビリティ** | 困難 | 単体テスト容易 | 品質向上 |

### 5.2 アーキテクチャによる効果

- **依存性の方向**: ドメイン層が最上位、技術詳細が下位層に分離
- **テスト容易性**: 各層を独立してテスト可能
- **保守性**: 責任分離により変更影響を局所化
- **拡張性**: 新機能追加時の影響範囲を明確化

## 6. 技術スタック

- **Runtime**: Deno 1.x
- **Database**: Supabase (PostgreSQL)
- **Testing**: Deno標準テストフレームワーク
- **CI/CD**: GitHub Actions
- **Architecture**: 軽量版クリーンアーキテクチャ
- **Deployment**: Supabase Edge Functions