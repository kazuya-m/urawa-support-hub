### 2.2 å®Ÿè£…æ¸ˆã¿ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£

```typescript
// src/domain/entities/NotificationHistory.ts
export class NotificationHistory {
  constructor(private props: NotificationHistoryProps) {
    this.validateNotificationHistory(props);
  }

  // ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯
  canSend(): boolean;
  isExpired(): boolean;  
  canRetry(): boolean;
  markAsSent(): void;
  markAsFailed(errorMessage: string): void;
  
  // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
  private validateNotificationHistory(props: NotificationHistoryProps): void;
}

// è¨­å®šé§†å‹•é€šçŸ¥ã‚¿ã‚¤ãƒŸãƒ³ã‚°
export const NOTIFICATION_TIMING_CONFIG = {
  day_before: {
    displayName: 'è²©å£²é–‹å§‹å‰æ—¥',
    calculateScheduledTime: (saleStartDate: Date) => Date,
    toleranceMs: 5 * 60 * 1000
  }
} as const;
```

## 3. å®Ÿè£…æ¸ˆã¿ãƒªãƒã‚¸ãƒˆãƒªå±¤

### 3.1 ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
// src/domain/interfaces/TicketRepository.ts
export interface TicketRepository {
  save(ticket: Ticket): Promise<void>;
  findById(id: string): Promise<Ticket | null>;
  findAll(): Promise<Ticket[]>;
  findByDateRange(startDate: Date, endDate: Date): Promise<Ticket[]>;
  update(ticket: Ticket): Promise<void>;
  delete(id: string): Promise<void>;
}

// src/domain/interfaces/NotificationRepository.ts  
export interface NotificationRepository {
  save(notification: NotificationHistory): Promise<void>;
  findById(id: string): Promise<NotificationHistory | null>;
  findByTicketId(ticketId: string): Promise<NotificationHistory[]>;
  update(notification: NotificationHistory): Promise<void>;
}
```

### 3.2 ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£å®Ÿè£…

```typescript
// src/infrastructure/repositories/TicketRepositoryImpl.ts
export class TicketRepositoryImpl implements TicketRepository {
  constructor(private supabase: SupabaseClient) {}
  
  async save(ticket: Ticket): Promise<void> {
    const data = TicketConverter.toDatabase(ticket);
    const { error } = await this.supabase.from('tickets').insert(data);
    if (error) handleSupabaseError('save ticket', error);
  }
}
```

### 3.3 å®Ÿè£…æ¸ˆã¿ãƒ†ã‚¹ãƒˆ

```typescript
// tests/integration/repository.test.ts - çµ±åˆãƒ†ã‚¹ãƒˆ
Deno.test('TicketRepository - save and findById', async () => {
  const ticket = new Ticket({...});
  await ticketRepo.save(ticket);
  const found = await ticketRepo.findById(ticket.id);
  assertEquals(found?.id, ticket.id);
});

// src/domain/entities/__tests__/Ticket.test.ts - ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ  
Deno.test('Ticket - æ­£å¸¸ãªãƒã‚±ãƒƒãƒˆä½œæˆ', () => {
  const ticket = new Ticket({...});
  assertEquals(ticket.id, 'test-id');
});

// 45ãƒ†ã‚¹ãƒˆå®Ÿè£…æ¸ˆã¿ï¼ˆunit + integrationï¼‰
import { TicketRepository } from '../../shared/repositories/TicketRepository.ts';

export class SupabaseTicketRepository implements TicketRepository {
  constructor(private supabase: SupabaseClient) {}

  async findFutureTickets(): Promise<Ticket[]> {
    const { data, error } = await this.supabase
      .from('tickets')
      .select('*')
      .gt('match_date', new Date().toISOString())
      .order('match_date', { ascending: true });

    if (error) throw new Error(`Failed to fetch future tickets: ${error.message}`);
    return data.map(this.mapToTicket);
  }

  async save(ticket: Ticket): Promise<void> {
    const { error } = await this.supabase
      .from('tickets')
      .insert(this.mapToDatabase(ticket));

    if (error) throw new Error(`Failed to save ticket: ${error.message}`);
  }

  async update(ticket: Ticket): Promise<void> {
    const { error } = await this.supabase
      .from('tickets')
      .update({ ...this.mapToDatabase(ticket), updated_at: new Date().toISOString() })
      .eq('id', ticket.id);

    if (error) throw new Error(`Failed to update ticket: ${error.message}`);
  }

  private mapToTicket(data: any): Ticket {
    return {
      id: data.id,
      matchName: data.match_name,
      matchDate: new Date(data.match_date),
      homeTeam: data.home_team,
      awayTeam: data.away_team,
      saleStartDate: new Date(data.sale_start_date),
      saleStartTime: data.sale_start_time,
      venue: data.venue,
      ticketTypes: data.ticket_types,
      ticketUrl: data.ticket_url,
      createdAt: new Date(data.created_at),
      updatedAt: new Date(data.updated_at),
    };
  }

  private mapToDatabase(ticket: Ticket): any {
    return {
      id: ticket.id,
      match_name: ticket.matchName,
      match_date: ticket.matchDate.toISOString(),
      home_team: ticket.homeTeam,
      away_team: ticket.awayTeam,
      sale_start_date: ticket.saleStartDate.toISOString(),
      sale_start_time: ticket.saleStartTime,
      venue: ticket.venue,
      ticket_types: ticket.ticketTypes,
      ticket_url: ticket.ticketUrl,
    };
  }
}
```

## 4. URLç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

### 4.1 URLè¨­å®šã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
// src/config/urlConfig.ts
export interface UrlConfig {
  readonly staticUrls: {
    readonly jleagueTicketBase: string;
    readonly urawaClubPage: string;
    readonly lineApiBase: string;
    readonly sitemapUrl: string;
  };
  dynamicUrls: {
    urawaAwayTabUrl: string;
    fallbackUrls: string[];
  };
  environmentUrls: {
    webhookUrl?: string;
    debugUrl?: string;
  };
}
```

### 4.2 UrlManagerå®Ÿè£…

```typescript
// src/services/UrlManager.ts
export class UrlManager {
  private static instance: UrlManager;
  private config: UrlConfig;

  private constructor() {
    this.config = {
      staticUrls: {
        jleagueTicketBase: 'https://www.jleague-ticket.jp',
        urawaClubPage: 'https://www.jleague-ticket.jp/club/ur/',
        lineApiBase: 'https://api.line.me/v2/bot',
        sitemapUrl: 'https://www.jleague-ticket.jp/sitemap.xml',
      },
      dynamicUrls: {
        urawaAwayTabUrl: Deno.env.get('URAWA_AWAY_TAB_URL') ||
          'https://www.jleague-ticket.jp/club/ur/?tab=away',
        fallbackUrls: [
          'https://www.jleague-ticket.jp/club/ur/#away',
          'https://www.jleague-ticket.jp/club/ur/away/',
          'https://www.jleague-ticket.jp/club/ur/?view=away',
        ],
      },
      environmentUrls: {
        webhookUrl: Deno.env.get('WEBHOOK_URL'),
        debugUrl: Deno.env.get('DEBUG_URL'),
      },
    };
  }

  public static getInstance(): UrlManager {
    if (!UrlManager.instance) {
      UrlManager.instance = new UrlManager();
    }
    return UrlManager.instance;
  }

  getStaticUrl(key: keyof typeof this.config.staticUrls): string {
    return this.config.staticUrls[key];
  }

  getDynamicUrl(key: keyof typeof this.config.dynamicUrls): string {
    return this.config.dynamicUrls[key];
  }

  getUrlWithFallbacks(): string[] {
    const primary = this.getDynamicUrl('urawaAwayTabUrl');
    const fallbacks = this.config.dynamicUrls.fallbackUrls;
    return [primary, ...fallbacks];
  }
}
```

## 5. ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°ã‚µãƒ¼ãƒ“ã‚¹å®Ÿè£…

### 5.1 ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°è¨­å®š

```typescript
// src/config/scrapingConfig.ts
export interface ScrapingConfig {
  awayTabSelectors: string[];
  selectors: {
    ticketContainer: string[];
    matchTitle: string[];
    matchDate: string[];
    saleDate: string[];
    ticketType: string[];
    venue: string[];
    ticketLink: string[];
  };
  awayKeywords: string[];
  generalSaleKeyword: string;
  timeouts: {
    pageLoad: number;
    elementWait: number;
    tabSwitch: number;
  };
}

export const optimizedScrapingConfig: ScrapingConfig = {
  awayTabSelectors: [
    '[data-tab="away"]',
    '.tab-away',
    '.away-tab',
    'a[href*="away"]',
    'button[data-target*="away"]',
    '.nav-away',
    '#away-tab',
  ],
  selectors: {
    ticketContainer: [
      '.ticket-item',
      '.match-item',
      '.game-item',
      '.event-item',
      '.item',
      '.card',
    ],
    matchTitle: [
      '.match-title',
      '.game-title',
      '.match-name',
      '.event-title',
      'h3',
      'h4',
      '.title',
    ],
    matchDate: [
      '.match-date',
      '.game-date',
      '.date',
      '.datetime',
      'time',
      '.schedule',
    ],
    saleDate: [
      '.sale-date',
      '.ticket-sale',
      '.sale-info',
      '.sale',
      '.ticket-info',
      '.info',
    ],
    ticketType: [
      '.ticket-type',
      '.seat-type',
      '.ticket-category',
      '.type',
      '.category',
    ],
    venue: [
      '.venue',
      '.stadium',
      '.location',
      '.place',
    ],
    ticketLink: [
      'a',
      '.ticket-link',
      '.buy-link',
      '.purchase-link',
    ],
  },
  awayKeywords: ['ãƒ“ã‚¸ã‚¿ãƒ¼', 'ãƒŸãƒƒã‚¯ã‚¹', 'ã‚¢ã‚¦ã‚§ã‚¤', 'ãƒãƒƒã‚¯ã‚¢ã‚¦ã‚§ã‚¤', 'ãƒ¡ã‚¤ãƒ³ã‚¢ã‚¦ã‚§ã‚¤'],
  generalSaleKeyword: 'ä¸€èˆ¬è²©å£²',
  timeouts: {
    pageLoad: 30000,
    elementWait: 10000,
    tabSwitch: 2000,
  },
};
```

### 5.2 AWAYã‚¿ãƒ–ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°ã‚µãƒ¼ãƒ“ã‚¹

```typescript
// src/features/away-tickets/services/AwayTabScrapingService.ts
import { chromium } from 'playwright';
import { UrlManager } from '../../shared/services/UrlManager.ts';

export class AwayTabScrapingService {
  private urlManager: UrlManager;

  constructor(private config: ScrapingConfig) {
    this.urlManager = UrlManager.getInstance();
  }

  async scrapeTickets(): Promise<
    { success: boolean; tickets: ScrapedTicketData[]; errors: string[] }
  > {
    let browser = null;
    try {
      browser = await chromium.launch({ headless: true });
      const page = await browser.newPage();

      // ãƒ¡ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã‚¢ã‚¯ã‚»ã‚¹
      const mainPageUrl = this.urlManager.getStaticUrl('urawaClubPage');
      await page.goto(mainPageUrl, { waitUntil: 'networkidle' });

      // AWAYã‚¿ãƒ–ã‚¢ã‚¯ã‚»ã‚¹ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¯¾å¿œï¼‰
      const tickets = await this.scrapeAwayTabWithFallback(page);

      return {
        success: true,
        tickets,
        errors: [],
      };
    } catch (error) {
      return {
        success: false,
        tickets: [],
        errors: [error.message],
      };
    } finally {
      if (browser) await browser.close();
    }
  }

  private async scrapeAwayTabWithFallback(page: any): Promise<ScrapedTicketData[]> {
    const awayUrls = this.urlManager.getUrlWithFallbacks();

    for (const url of awayUrls) {
      try {
        console.log(`Trying away tab URL: ${url}`);

        if (url.includes('?tab=away') || url.includes('#away')) {
          await page.goto(url, { waitUntil: 'networkidle', timeout: 15000 });
        } else {
          await this.clickAwayTab(page);
        }

        const tickets = await this.extractAwayTickets(page);
        if (tickets.length > 0) {
          console.log(`Success with URL: ${url}, found ${tickets.length} tickets`);
          return tickets;
        }
      } catch (error) {
        console.log(`Failed with URL: ${url}, error: ${error.message}`);
        continue;
      }
    }

    throw new Error('All away tab access methods failed');
  }

  private async clickAwayTab(page: any): Promise<void> {
    for (const selector of this.config.awayTabSelectors) {
      try {
        const element = await page.$(selector);
        if (element) {
          await element.click();
          await page.waitForTimeout(this.config.timeouts.tabSwitch);
          return;
        }
      } catch (error) {
        continue;
      }
    }
    throw new Error('Away tab not found');
  }

  private async extractAwayTickets(page: any): Promise<ScrapedTicketData[]> {
    await page.waitForSelector(this.config.selectors.ticketContainer[0], {
      timeout: this.config.timeouts.elementWait,
    });

    const ticketElements = await page.$eval(
      this.config.selectors.ticketContainer.join(','),
      (elements, selectors) => {
        return elements.map((el) => ({
          matchName: this.getTextBySelectors(el, selectors.matchTitle) || '',
          matchDate: this.getTextBySelectors(el, selectors.matchDate) || '',
          saleDate: this.getTextBySelectors(el, selectors.saleDate) || '',
          ticketTypes: this.getTextArrayBySelectors(el, selectors.ticketType),
          venue: this.getTextBySelectors(el, selectors.venue) || '',
          ticketUrl: this.getHrefBySelectors(el, selectors.ticketLink) || '',
        }));
      },
      this.config.selectors,
    );

    return ticketElements.filter((ticket) => this.isValidAwayTicket(ticket));
  }

  private isValidAwayTicket(ticket: ScrapedTicketData): boolean {
    if (!ticket.matchName || !ticket.saleDate) return false;

    // ã‚¢ã‚¦ã‚§ã‚¤æˆ¦ã®ç‰¹å¾´ç¢ºèª
    const hasAwayIndicator = !ticket.venue.includes('åŸ¼ç‰ã‚¹ã‚¿ã‚¸ã‚¢ãƒ ') ||
      /(.+)\s*(vs|å¯¾)\s*æµ¦å’Œãƒ¬ãƒƒã‚º/.test(ticket.matchName);

    // ã‚¢ã‚¦ã‚§ã‚¤å‘ã‘ãƒã‚±ãƒƒãƒˆç¨®åˆ¥ç¢ºèª
    const hasAwayTicketType = ticket.ticketTypes.some((type) =>
      this.config.awayKeywords.some((keyword) => type.includes(keyword))
    );

    // ä¸€èˆ¬è²©å£²ç¢ºèª
    const isGeneralSale = ticket.ticketTypes.some((type) =>
      type.includes(this.config.generalSaleKeyword)
    );

    return hasAwayIndicator && hasAwayTicketType && isGeneralSale;
  }
}
```

## 6. é€šçŸ¥ã‚µãƒ¼ãƒ“ã‚¹å®Ÿè£…

### 6.1 NotificationServiceã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```typescript
// src/features/shared/services/NotificationService.ts
export interface NotificationService {
  sendNotification(message: NotificationMessage): Promise<{ success: boolean; error?: string }>;
}
```

### 6.2 LINEé€šçŸ¥ã‚µãƒ¼ãƒ“ã‚¹å®Ÿè£…

```typescript
// src/features/away-tickets/services/LineNotificationService.ts
export class LineNotificationService implements NotificationService {
  constructor(
    private channelAccessToken: string,
    private groupChatId: string,
  ) {}

  async sendNotification(
    message: NotificationMessage,
  ): Promise<{ success: boolean; error?: string }> {
    try {
      const response = await fetch('https://api.line.me/v2/bot/message/push', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.channelAccessToken}`,
        },
        body: JSON.stringify({
          to: this.groupChatId,
          messages: [{ type: 'text', text: message.content }],
        }),
      });

      if (!response.ok) {
        const error = await response.text();
        return { success: false, error: `LINE API Error: ${response.status} - ${error}` };
      }

      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
}
```

## 7. ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°

### 7.1 ãƒã‚±ãƒƒãƒˆé–¢é€£ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£

```typescript
// src/features/shared/utils/ticketUtils.ts
export function generateTicketId(matchName: string, matchDate: Date): string {
  const dateStr = matchDate.toISOString().split('T')[0];
  const input = `${matchName}-${dateStr}`;

  // ç°¡æ˜“ãƒãƒƒã‚·ãƒ¥é–¢æ•°ï¼ˆDenoç’°å¢ƒå¯¾å¿œï¼‰
  let hash = 0;
  for (let i = 0; i < input.length; i++) {
    const char = input.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // 32bitæ•´æ•°ã«å¤‰æ›
  }
  return Math.abs(hash).toString(36).substring(0, 16);
}

export function parseScrapedTicket(scraped: ScrapedTicketData): Ticket {
  const matchDate = parseDateString(scraped.matchDate);
  const saleStartDate = parseDateString(scraped.saleDate);
  const [homeTeam, awayTeam] = parseTeamNames(scraped.matchName);

  return {
    id: generateTicketId(scraped.matchName, matchDate),
    matchName: scraped.matchName,
    matchDate,
    homeTeam,
    awayTeam,
    saleStartDate,
    venue: scraped.venue,
    ticketTypes: scraped.ticketTypes,
    ticketUrl: scraped.ticketUrl,
    createdAt: new Date(),
    updatedAt: new Date(),
  };
}

export function parseDateString(dateStr: string): Date {
  const patterns = [
    /(\d{4})å¹´(\d{1,2})æœˆ(\d{1,2})æ—¥\s*(\d{1,2}):(\d{2})/,
    /(\d{4})\/(\d{1,2})\/(\d{1,2})\s*(\d{1,2}):(\d{2})/,
    /(\d{1,2})\/(\d{1,2})\s*(\d{1,2}):(\d{2})/,
    /(\d{1,2})æœˆ(\d{1,2})æ—¥\s*(\d{1,2}):(\d{2})/,
  ];

  for (const pattern of patterns) {
    const match = dateStr.match(pattern);
    if (match) {
      const currentYear = new Date().getFullYear();
      let [, year, month, day, hour, minute] = match;

      if (pattern.source.includes('\\d{1,2}æœˆ') || pattern.source.includes('\\d{1,2}\\/')) {
        year = currentYear.toString();
      }

      const parsedDate = new Date(
        parseInt(year),
        parseInt(month) - 1,
        parseInt(day),
        parseInt(hour),
        parseInt(minute),
      );

      if (parsedDate < new Date() && !year) {
        parsedDate.setFullYear(currentYear + 1);
      }

      return parsedDate;
    }
  }

  throw new Error(`Cannot parse date string: ${dateStr}`);
}

export function createNotificationMessage(ticket: Ticket, type: string): string {
  const typeEmoji = {
    'day_before': 'ğŸ“…',
    'hour_before': 'â°',
    'minutes_before': 'ğŸš¨',
  };

  const typeText = {
    'day_before': 'è²©å£²é–‹å§‹å‰æ—¥',
    'hour_before': 'è²©å£²é–‹å§‹1æ™‚é–“å‰',
    'minutes_before': 'è²©å£²é–‹å§‹15åˆ†å‰',
  };

  return `${typeEmoji[type] || 'ğŸŸï¸'} æµ¦å’Œãƒ¬ãƒƒã‚º ã‚¢ã‚¦ã‚§ã‚¤æˆ¦ãƒã‚±ãƒƒãƒˆè²©å£²ã®ãŠçŸ¥ã‚‰ã›

ğŸ“ ${typeText[type] || type}é€šçŸ¥

ğŸŸï¸ è©¦åˆ: ${ticket.matchName}
ğŸ“… è©¦åˆæ—¥: ${ticket.matchDate.toLocaleDateString('ja-JP')} ${
    ticket.matchDate.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' })
  }
ğŸ« è²©å£²é–‹å§‹: ${ticket.saleStartDate.toLocaleDateString('ja-JP')} ${
    ticket.saleStartDate.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' })
  }
ğŸŸï¸ ä¼šå ´: ${ticket.venue}

ğŸ« ãƒã‚±ãƒƒãƒˆè³¼å…¥ã¯ã“ã¡ã‚‰:
${ticket.ticketUrl}

#æµ¦å’Œãƒ¬ãƒƒã‚º #ã‚¢ã‚¦ã‚§ã‚¤æˆ¦ #${type}`;
}
```

## 8. Edge Functionså®Ÿè£…

### 8.1 daily-check Function

```typescript
// supabase/functions/daily-check/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from '@supabase/supabase-js';
import { SupabaseTicketRepository } from '../../../src/features/away-tickets/repositories/SupabaseTicketRepository.ts';
import { AwayTabScrapingService } from '../../../src/features/away-tickets/services/AwayTabScrapingService.ts';
import { LineNotificationService } from '../../../src/features/away-tickets/services/LineNotificationService.ts';
import { optimizedScrapingConfig } from '../../../src/config/scrapingConfig.ts';
import { parseScrapedTicket } from '../../../src/features/shared/utils/ticketUtils.ts';

serve(async (req: Request) => {
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'POST',
    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  };

  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    // ã‚·ãƒ¼ã‚ºãƒ³ã‚ªãƒ•ãƒã‚§ãƒƒã‚¯ï¼ˆ12æœˆã‚¹ã‚­ãƒƒãƒ—ï¼‰
    const currentMonth = new Date().getMonth() + 1;
    if (currentMonth === 12) {
      return new Response(
        JSON.stringify({
          message: 'ã‚·ãƒ¼ã‚ºãƒ³ã‚ªãƒ•ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ',
          month: currentMonth,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        },
      );
    }

    // ä¾å­˜é–¢ä¿‚åˆæœŸåŒ–
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
    );

    const ticketRepo = new SupabaseTicketRepository(supabase);
    const scrapingService = new AwayTabScrapingService(optimizedScrapingConfig);
    const notificationService = new LineNotificationService(
      Deno.env.get('LINE_CHANNEL_ACCESS_TOKEN')!,
      Deno.env.get('LINE_GROUP_CHAT_ID')!,
    );

    // AWAYã‚¿ãƒ–ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°å®Ÿè¡Œ
    console.log('Starting away tab scraping...');
    const scrapingResult = await scrapingService.scrapeTickets();

    if (!scrapingResult.success) {
      await notificationService.sendNotification({
        content: `âŒ ã‚¢ã‚¦ã‚§ã‚¤ãƒã‚±ãƒƒãƒˆæƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ\n\nã‚¨ãƒ©ãƒ¼:\n${
          scrapingResult.errors.join('\n')
        }`,
        type: 'error',
      });

      return new Response(
        JSON.stringify({
          success: false,
          errors: scrapingResult.errors,
        }),
        {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        },
      );
    }

    // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã¨ã®æ¯”è¼ƒãƒ»æ›´æ–°å‡¦ç†
    console.log(`Found ${scrapingResult.tickets.length} away tickets`);
    const existingTickets = await ticketRepo.findFutureTickets();

    let newCount = 0;
    let updateCount = 0;
    const processedTickets: string[] = [];

    for (const scrapedData of scrapingResult.tickets) {
      try {
        const ticket = parseScrapedTicket(scrapedData);
        const existing = await ticketRepo.findById(ticket.id);

        if (!existing) {
          await ticketRepo.save(ticket);
          newCount++;
          processedTickets.push(`æ–°è¦: ${ticket.matchName}`);
          console.log(`æ–°è¦ãƒã‚±ãƒƒãƒˆä¿å­˜: ${ticket.matchName}`);
        } else if (existing.saleStartDate.getTime() !== ticket.saleStartDate.getTime()) {
          await ticketRepo.update(ticket);
          updateCount++;
          processedTickets.push(`æ›´æ–°: ${ticket.matchName}`);
          console.log(`ãƒã‚±ãƒƒãƒˆæ›´æ–°: ${ticket.matchName}`);
        }
      } catch (error) {
        console.error('ãƒã‚±ãƒƒãƒˆå‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
        processedTickets.push(`ã‚¨ãƒ©ãƒ¼: ${scrapedData.matchName} - ${error.message}`);
      }
    }

    // å¤ã„ãƒ‡ãƒ¼ã‚¿ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
    await ticketRepo.deleteExpired(oneWeekAgo);

    // å‡¦ç†çµæœã®é€šçŸ¥ï¼ˆæ–°è¦ãƒ»æ›´æ–°ãŒã‚ã‚‹å ´åˆã®ã¿ï¼‰
    if (newCount > 0 || updateCount > 0) {
      await notificationService.sendNotification({
        content:
          `ğŸ”„ ã‚¢ã‚¦ã‚§ã‚¤ãƒã‚±ãƒƒãƒˆæƒ…å ±ã‚’æ›´æ–°ã—ã¾ã—ãŸ\n\næ–°è¦: ${newCount}ä»¶\næ›´æ–°: ${updateCount}ä»¶\n\nè©³ç´°:\n${
            processedTickets.join('\n')
          }`,
        type: 'update',
      });
    }

    return new Response(
      JSON.stringify({
        success: true,
        newTickets: newCount,
        updatedTickets: updateCount,
        totalScraped: scrapingResult.tickets.length,
        processedTickets,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      },
    );
  } catch (error) {
    console.error('Daily check error:', error);
    return new Response(
      JSON.stringify({
        error: 'Internal server error',
        message: error.message,
        timestamp: new Date().toISOString(),
      }),
      {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      },
    );
  }
});
```

## 9. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒ

### 9.1 åŸºæœ¬ã‚¹ã‚­ãƒ¼ãƒ

```sql
-- supabase/migrations/001_initial_schema.sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ãƒã‚±ãƒƒãƒˆæƒ…å ±ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE tickets (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  match_name TEXT NOT NULL,
  match_date TIMESTAMPTZ NOT NULL,
  home_team TEXT NOT NULL,
  away_team TEXT NOT NULL,
  sale_start_date TIMESTAMPTZ NOT NULL,
  sale_start_time TEXT,
  venue TEXT NOT NULL,
  ticket_types TEXT[] NOT NULL,
  ticket_url TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- åˆ¶ç´„
  CONSTRAINT match_date_future CHECK (match_date > created_at),
  CONSTRAINT sale_date_valid CHECK (sale_start_date > created_at),
  CONSTRAINT ticket_types_not_empty CHECK (array_length(ticket_types, 1) > 0),
  CONSTRAINT valid_url CHECK (ticket_url LIKE 'http%')
);

-- é€šçŸ¥å±¥æ­´ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE notification_history (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  ticket_id UUID REFERENCES tickets(id) ON DELETE CASCADE,
  notification_type TEXT NOT NULL CHECK (
    notification_type IN ('day_before', 'hour_before', 'minutes_before')
  ),
  scheduled_at TIMESTAMPTZ NOT NULL,
  sent_at TIMESTAMPTZ,
  status TEXT NOT NULL DEFAULT 'pending' CHECK (
    status IN ('pending', 'sent', 'failed')
  ),
  error_message TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- é‡è¤‡é˜²æ­¢åˆ¶ç´„
  UNIQUE(ticket_id, notification_type)
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆ
CREATE INDEX idx_tickets_match_date ON tickets(match_date);
CREATE INDEX idx_tickets_sale_start_date ON tickets(sale_start_date);
CREATE INDEX idx_notification_history_scheduled_at ON notification_history(scheduled_at);
CREATE INDEX idx_notification_history_status ON notification_history(status);

-- RLSæœ‰åŠ¹åŒ–
ALTER TABLE tickets ENABLE ROW LEVEL SECURITY;
ALTER TABLE notification_history ENABLE ROW LEVEL SECURITY;

-- Service Roleç”¨ãƒãƒªã‚·ãƒ¼
CREATE POLICY "Service role full access tickets" ON tickets
  FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');

CREATE POLICY "Service role full access notifications" ON notification_history
  FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');
```

### 9.2 Cronã‚¸ãƒ§ãƒ–è¨­å®š

```sql
-- supabase/migrations/002_cron_jobs.sql
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- æ¯æ—¥12:00 JST (03:00 UTC) ã§ãƒã‚±ãƒƒãƒˆãƒã‚§ãƒƒã‚¯
SELECT cron.schedule(
  'daily-ticket-check',
  '0 3 * * *',
  $
  SELECT net.http_post(
    url := current_setting('app.base_url') || '/functions/v1/daily-check',
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || current_setting('app.service_role_key')
    ),
    body := jsonb_build_object('source', 'cron')
  ) as request_id;
  $
);

-- 5åˆ†é–“éš”ã§é€šçŸ¥ãƒã‚§ãƒƒã‚¯
SELECT cron.schedule(
  'notification-check',
  '*/5 * * * *',
  $
  SELECT net.http_post(
    url := current_setting('app.base_url') || '/functions/v1/notification-check',
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || current_setting('app.service_role_key')
    ),
    body := jsonb_build_object('source', 'cron')
  ) as request_id;
  $
);
```

## 10. ãƒ†ã‚¹ãƒˆè¨­è¨ˆ

### 10.1 å˜ä½“ãƒ†ã‚¹ãƒˆä¾‹

````typescript
// tests/features/shared/utils/ticketUtils.test.ts
import { assertEquals, assertThrows } from "std/testing/asserts.ts";
import { generateTicketId, parseDateString } from "@/features/shared/utils/ticketUtils.ts";

## 10. ãƒ†ã‚¹ãƒˆè¨­è¨ˆ

### 10.1 å˜ä½“ãƒ†ã‚¹ãƒˆä¾‹
```typescript
// tests/features/shared/utils/ticketUtils.test.ts
import { assertEquals, assertThrows } from "std/testing/asserts.ts";
import { generateTicketId, parseDateString } from "@/features/shared/utils/ticketUtils.ts";

Deno.test("generateTicketId - should create consistent ID for same input", () => {
  const matchName = "FCæ±äº¬ vs æµ¦å’Œãƒ¬ãƒƒã‚º";
  const matchDate = new Date('2024-03-15T19:30:00+09:00');
  
  const id1 = generateTicketId(matchName, matchDate);
  const id2 = generateTicketId(matchName, matchDate);
  
  assertEquals(id1, id2);
  assertEquals(typeof id1, 'string');
  assertEquals(id1.length, 16);
});

Deno.test("parseDateString - should handle multiple date formats", () => {
  const testCases = [
    { input: "2024å¹´3æœˆ15æ—¥ 19:30", expected: new Date(2024, 2, 15, 19, 30) },
    { input: "2024/03/15 19:30", expected: new Date(2024, 2, 15, 19, 30) },
    { input: "3/15 19:30", expected: new Date(new Date().getFullYear(), 2, 15, 19, 30) }
  ];
  
  testCases.forEach(({ input, expected }) => {
    const result = parseDateString(input);
    assertEquals(result.getFullYear(), expected.getFullYear());
    assertEquals(result.getMonth(), expected.getMonth());
    assertEquals(result.getDate(), expected.getDate());
    assertEquals(result.getHours(), expected.getHours());
    assertEquals(result.getMinutes(), expected.getMinutes());
  });
});

Deno.test("parseDateString - should throw error for invalid format", () => {
  assertThrows(
    () => parseDateString("invalid date"),
    Error,
    "Cannot parse date string"
  );
});
````

### 10.2 çµ±åˆãƒ†ã‚¹ãƒˆä¾‹

```typescript
// tests/integration/TicketRepository.test.ts
import { assert, assertEquals } from 'std/testing/asserts.ts';
import { createClient } from '@supabase/supabase-js';
import { SupabaseTicketRepository } from '@/features/away-tickets/repositories/SupabaseTicketRepository.ts';

Deno.test('SupabaseTicketRepository - CRUD operations', async () => {
  const supabase = createClient(
    Deno.env.get('SUPABASE_URL')!,
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
  );

  const repository = new SupabaseTicketRepository(supabase);

  // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ä½œæˆ
  const testTicket = {
    id: 'test-ticket-id',
    matchName: 'ãƒ†ã‚¹ãƒˆè©¦åˆ vs æµ¦å’Œãƒ¬ãƒƒã‚º',
    matchDate: new Date('2025-03-15T19:30:00+09:00'),
    homeTeam: 'ãƒ†ã‚¹ãƒˆãƒãƒ¼ãƒ ',
    awayTeam: 'æµ¦å’Œãƒ¬ãƒƒã‚º',
    saleStartDate: new Date('2025-03-01T10:00:00+09:00'),
    venue: 'ãƒ†ã‚¹ãƒˆã‚¹ã‚¿ã‚¸ã‚¢ãƒ ',
    ticketTypes: ['ãƒ“ã‚¸ã‚¿ãƒ¼å¸­', 'ä¸€èˆ¬è²©å£²'],
    ticketUrl: 'https://example.com/test-ticket',
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  try {
    // ä¿å­˜ãƒ†ã‚¹ãƒˆ
    await repository.save(testTicket);

    // å–å¾—ãƒ†ã‚¹ãƒˆ
    const savedTicket = await repository.findById(testTicket.id);
    assert(savedTicket !== null);
    assertEquals(savedTicket.matchName, testTicket.matchName);

    // æ›´æ–°ãƒ†ã‚¹ãƒˆ
    testTicket.matchName = 'æ›´æ–°æ¸ˆã¿è©¦åˆå';
    await repository.update(testTicket);

    const updatedTicket = await repository.findById(testTicket.id);
    assertEquals(updatedTicket?.matchName, 'æ›´æ–°æ¸ˆã¿è©¦åˆå');
  } finally {
    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    await supabase.from('tickets').delete().eq('id', testTicket.id);
  }
});
```

## 11. è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«

### 11.1 Denoè¨­å®š

```json
// deno.json
{
  "compilerOptions": {
    "allowJs": true,
    "lib": ["deno.window"],
    "strict": true,
    "noImplicitAny": true,
    "noImplicitReturns": true
  },
  "importMap": "./import_map.json",
  "tasks": {
    "start": "supabase start",
    "dev": "supabase functions serve --debug",
    "test": "deno test --allow-all --coverage=coverage",
    "deploy": "supabase functions deploy",
    "db:reset": "supabase db reset",
    "db:push": "supabase db push",
    "lint": "deno lint",
    "fmt": "deno fmt"
  },
  "lint": {
    "files": {
      "include": ["src/", "supabase/functions/"],
      "exclude": ["supabase/functions/_shared/"]
    }
  },
  "fmt": {
    "options": {
      "useTabs": false,
      "lineWidth": 100,
      "indentWidth": 2,
      "singleQuote": true
    }
  }
}
```

### 11.2 Import Map

```json
// import_map.json
{
  "imports": {
    "@supabase/supabase-js": "https://esm.sh/@supabase/supabase-js@2",
    "playwright": "https://deno.land/x/playwright@0.4.0/mod.ts",
    "std/": "https://deno.land/std@0.208.0/",
    "@/": "./src/",
    "date-fns": "https://esm.sh/date-fns@2.30.0",
    "testing/": "https://deno.land/std@0.208.0/testing/"
  }
}
```

## 12. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°è¨­è¨ˆ

### 12.1 ã‚¨ãƒ©ãƒ¼åˆ†é¡

```typescript
// src/features/shared/errors/CustomErrors.ts
export class ScrapingError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = 'ScrapingError';
  }
}

export class DatabaseError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = 'DatabaseError';
  }
}

export class NotificationError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = 'NotificationError';
  }
}
```

### 12.2 ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æˆ¦ç•¥

```typescript
// src/features/shared/utils/errorHandler.ts
export class ErrorHandler {
  static async handleScrapingError(
    error: Error,
    notificationService: NotificationService,
  ): Promise<void> {
    console.error('Scraping error:', error);

    await notificationService.sendNotification({
      content: `ğŸš¨ ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°ã‚¨ãƒ©ãƒ¼\n\n${error.message}\n\næ™‚åˆ»: ${
        new Date().toLocaleString('ja-JP')
      }`,
      type: 'error',
    });
  }

  static async handleDatabaseError(
    error: Error,
    notificationService: NotificationService,
  ): Promise<void> {
    console.error('Database error:', error);

    await notificationService.sendNotification({
      content: `ğŸ’¾ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼\n\n${error.message}\n\næ™‚åˆ»: ${
        new Date().toLocaleString('ja-JP')
      }`,
      type: 'error',
    });
  }

  static async handleNotificationError(error: Error): Promise<void> {
    console.error('Notification error:', error);
    // é€šçŸ¥ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ãƒ­ã‚°å‡ºåŠ›ã®ã¿ï¼ˆç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢ï¼‰
  }
}
```

## 13. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–è¨­è¨ˆ

### 13.1 ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–

```typescript
// src/features/shared/utils/performanceUtils.ts
export class PerformanceOptimizer {
  static async withMemoryMonitoring<T>(operation: () => Promise<T>, label: string): Promise<T> {
    const memBefore = Deno.memoryUsage();
    console.log(`[${label}] Memory before: ${Math.round(memBefore.heapUsed / 1024 / 1024)}MB`);

    try {
      const result = await operation();

      const memAfter = Deno.memoryUsage();
      console.log(`[${label}] Memory after: ${Math.round(memAfter.heapUsed / 1024 / 1024)}MB`);
      console.log(
        `[${label}] Memory diff: ${
          Math.round((memAfter.heapUsed - memBefore.heapUsed) / 1024 / 1024)
        }MB`,
      );

      return result;
    } catch (error) {
      const memError = Deno.memoryUsage();
      console.log(`[${label}] Memory on error: ${Math.round(memError.heapUsed / 1024 / 1024)}MB`);
      throw error;
    }
  }

  static async withTimeout<T>(
    operation: () => Promise<T>,
    timeoutMs: number,
    label: string,
  ): Promise<T> {
    const timeoutPromise = new Promise<never>((_, reject) => {
      setTimeout(() => reject(new Error(`${label} timed out after ${timeoutMs}ms`)), timeoutMs);
    });

    return Promise.race([operation(), timeoutPromise]);
  }
}
```

### 13.2 ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æœ€é©åŒ–

```sql
-- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¯ã‚¨ãƒªæœ€é©åŒ–ã®ãŸã‚ã®è¿½åŠ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX CONCURRENTLY idx_tickets_composite ON tickets(away_team, match_date) 
WHERE away_team = 'æµ¦å’Œãƒ¬ãƒƒã‚º';

CREATE INDEX CONCURRENTLY idx_notification_pending ON notification_history(scheduled_at) 
WHERE status = 'pending';

-- çµ±è¨ˆæƒ…å ±ã®å®šæœŸæ›´æ–°
CREATE OR REPLACE FUNCTION update_table_statistics()
RETURNS void AS $
BEGIN
  ANALYZE tickets;
  ANALYZE notification_history;
END;
$ LANGUAGE plpgsql;
```

## 14. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆ

### 14.1 å…¥åŠ›å€¤æ¤œè¨¼

```typescript
// src/features/shared/utils/validation.ts
export class InputValidator {
  static validateTicketUrl(url: string): boolean {
    try {
      const parsedUrl = new URL(url);
      return parsedUrl.protocol === 'https:' &&
        parsedUrl.hostname.includes('jleague-ticket.jp');
    } catch {
      return false;
    }
  }

  static sanitizeMatchName(matchName: string): string {
    return matchName.replace(/[<>\"'&]/g, '').trim().substring(0, 255);
  }

  static validateDateRange(date: Date): boolean {
    const now = new Date();
    const maxFuture = new Date();
    maxFuture.setFullYear(now.getFullYear() + 1);

    return date > now && date < maxFuture;
  }
}
```

### 14.2 ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡

```sql
-- ã‚ˆã‚Šå³å¯†ãªRLSãƒãƒªã‚·ãƒ¼
DROP POLICY IF EXISTS "Service role full access tickets" ON tickets;
CREATE POLICY "Service role tickets access" ON tickets
  FOR ALL 
  USING (auth.jwt() ->> 'role' = 'service_role')
  WITH CHECK (auth.jwt() ->> 'role' = 'service_role');

-- èª­ã¿å–ã‚Šå°‚ç”¨ãƒ“ãƒ¥ãƒ¼ã®ä½œæˆï¼ˆå°†æ¥ã®ç®¡ç†ç”»é¢ç”¨ï¼‰
CREATE VIEW public_tickets AS
SELECT 
  match_name,
  match_date,
  venue,
  sale_start_date,
  array_length(ticket_types, 1) as ticket_type_count
FROM tickets
WHERE match_date > NOW()
ORDER BY match_date;
```

## 15. ç›£è¦–ãƒ»ãƒ­ã‚°è¨­è¨ˆ

### 15.1 æ§‹é€ åŒ–ãƒ­ã‚°

```typescript
// src/features/shared/utils/logger.ts
export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
}

export class Logger {
  private static level: LogLevel = LogLevel.INFO;

  static setLevel(level: LogLevel) {
    this.level = level;
  }

  static debug(message: string, data?: any) {
    if (this.level <= LogLevel.DEBUG) {
      this.log('DEBUG', message, data);
    }
  }

  static info(message: string, data?: any) {
    if (this.level <= LogLevel.INFO) {
      this.log('INFO', message, data);
    }
  }

  static warn(message: string, data?: any) {
    if (this.level <= LogLevel.WARN) {
      this.log('WARN', message, data);
    }
  }

  static error(message: string, error?: Error, data?: any) {
    this.log('ERROR', message, { error: error?.message, stack: error?.stack, ...data });
  }

  private static log(level: string, message: string, data?: any) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      ...data,
    };

    console.log(JSON.stringify(logEntry));
  }
}
```

### 15.2 ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†

```typescript
// src/features/shared/utils/metrics.ts
export class Metrics {
  private static metrics: Map<string, number> = new Map();

  static increment(key: string, value: number = 1) {
    const current = this.metrics.get(key) || 0;
    this.metrics.set(key, current + value);
  }

  static set(key: string, value: number) {
    this.metrics.set(key, value);
  }

  static getAll(): Record<string, number> {
    return Object.fromEntries(this.metrics);
  }

  static async recordExecutionTime<T>(key: string, operation: () => Promise<T>): Promise<T> {
    const startTime = performance.now();
    try {
      const result = await operation();
      const duration = performance.now() - startTime;
      this.set(`${key}_duration_ms`, Math.round(duration));
      this.increment(`${key}_success_count`);
      return result;
    } catch (error) {
      const duration = performance.now() - startTime;
      this.set(`${key}_duration_ms`, Math.round(duration));
      this.increment(`${key}_error_count`);
      throw error;
    }
  }
}
```

## 16. ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆè¨­è¨ˆ

### 16.1 æ®µéšçš„ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ

```bash
# ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆä¾‹
#!/bin/bash

# ç’°å¢ƒå¤‰æ•°ãƒã‚§ãƒƒã‚¯
if [ -z "$SUPABASE_PROJECT_ID" ]; then
  echo "Error: SUPABASE_PROJECT_ID is not set"
  exit 1
fi

# ãƒªãƒ³ã‚¯ãƒã‚§ãƒƒã‚¯
supabase link --project-ref $SUPABASE_PROJECT_ID

# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
echo "Validating database schema..."
supabase db diff --schema public

# Edge Functionsã®ãƒ†ã‚¹ãƒˆ
echo "Testing Edge Functions locally..."
deno test --allow-all

# æ®µéšçš„ãƒ‡ãƒ—ãƒ­ã‚¤
echo "Deploying database migrations..."
supabase db push

echo "Deploying Edge Functions..."
supabase functions deploy daily-check --no-verify-jwt
supabase functions deploy notification-check --no-verify-jwt

echo "Deployment completed successfully!"
```

### 16.2 ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æˆ¦ç•¥

```sql
-- ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ“ãƒ¥ãƒ¼ä½œæˆ
CREATE VIEW deployment_backup AS
SELECT 
  'tickets' as table_name,
  COUNT(*) as record_count,
  MAX(created_at) as latest_record,
  NOW() as backup_timestamp
FROM tickets
UNION ALL
SELECT 
  'notification_history' as table_name,
  COUNT(*) as record_count,
  MAX(created_at) as latest_record,
  NOW() as backup_timestamp
FROM notification_history;
```

## 17. Claude Codeå®Ÿè£…ã‚¬ã‚¤ãƒ‰

### 17.1 å®Ÿè£…ã®æ®µéšçš„é€²è¡Œ

1. **Phase 1: åŸºç›¤æ§‹ç¯‰**
   - Supabaseãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆæœŸåŒ–
   - ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒé©ç”¨
   - åŸºæœ¬çš„ãªå‹å®šç¾©ä½œæˆ

2. **Phase 2: ãƒªãƒã‚¸ãƒˆãƒªå±¤**
   - ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®šç¾©
   - Supabaseå®Ÿè£…
   - åŸºæœ¬çš„ãªCRUDæ“ä½œ

3. **Phase 3: ã‚µãƒ¼ãƒ“ã‚¹å±¤**
   - URLç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
   - ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°ã‚µãƒ¼ãƒ“ã‚¹ï¼ˆå®Ÿéš›ã®ã‚µã‚¤ãƒˆèª¿æŸ»å¾Œï¼‰
   - é€šçŸ¥ã‚µãƒ¼ãƒ“ã‚¹

4. **Phase 4: Edge Functions**
   - daily-checkå®Ÿè£…
   - notification-checkå®Ÿè£…
   - ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

5. **Phase 5: ãƒ†ã‚¹ãƒˆãƒ»æœ€é©åŒ–**
   - å˜ä½“ãƒ†ã‚¹ãƒˆ
   - çµ±åˆãƒ†ã‚¹ãƒˆ
   - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹èª¿æ•´

### 17.2 å®Ÿè£…æ™‚ã®æ³¨æ„ç‚¹

- **ã‚µã‚¤ãƒˆæ§‹é€ èª¿æŸ»**: å®Ÿè£…å‰ã«å¿…ãšJãƒªãƒ¼ã‚°ãƒã‚±ãƒƒãƒˆã‚µã‚¤ãƒˆã®è©³ç´°èª¿æŸ»ã‚’å®Ÿæ–½
- **æ®µéšçš„ãƒ†ã‚¹ãƒˆ**: å„æ©Ÿèƒ½ã‚’å€‹åˆ¥ã«ãƒ†ã‚¹ãƒˆã—ã¦ã‹ã‚‰çµ±åˆ
- **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**: å¤–éƒ¨APIå‘¼ã³å‡ºã—ã¯å¿…ãštry-catch
- **ãƒ­ã‚°å‡ºåŠ›**: ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®é©åˆ‡ãªå‡ºåŠ›
- **ãƒ¡ãƒ¢ãƒªç›£è¦–**: 512MBåˆ¶é™ã‚’æ„è­˜ã—ãŸå®Ÿè£…

ã“ã®è©³ç´°è¨­è¨ˆæ›¸ã«å¾“ã£ã¦å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€å …ç‰¢ã§ä¿å®ˆæ€§ã®é«˜ã„ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã§ãã¾ã™ã€‚# urawa-support-hub
è©³ç´°è¨­è¨ˆæ›¸

## 1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹æˆ

```
urawa-support-hub/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ features/
â”‚   â”‚   â”œâ”€â”€ away-tickets/               # ã‚¢ã‚¦ã‚§ã‚¤ãƒã‚±ãƒƒãƒˆç›£è¦–æ©Ÿèƒ½
â”‚   â”‚   â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ SupabaseTicketRepository.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ SupabaseNotificationRepository.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AwayTabScrapingService.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ LineNotificationService.ts
â”‚   â”‚   â”‚   â””â”€â”€ types/
â”‚   â”‚   â”‚       â”œâ”€â”€ Ticket.ts
â”‚   â”‚   â”‚       â””â”€â”€ NotificationHistory.ts
â”‚   â”‚   â”œâ”€â”€ hotel-booking/              # Phase 2: ãƒ›ãƒ†ãƒ«äºˆç´„ãƒªãƒã‚¤ãƒ³ãƒ‰
â”‚   â”‚   â”œâ”€â”€ home-tickets/               # Phase 2: ãƒ›ãƒ¼ãƒ ãƒã‚±ãƒƒãƒˆã‚¢ãƒ©ãƒ¼ãƒˆ
â”‚   â”‚   â””â”€â”€ shared/                     # å…±é€šæ©Ÿèƒ½
â”‚   â”‚       â”œâ”€â”€ repositories/
â”‚   â”‚       â”‚   â”œâ”€â”€ TicketRepository.ts
â”‚   â”‚       â”‚   â””â”€â”€ NotificationRepository.ts
â”‚   â”‚       â”œâ”€â”€ services/
â”‚   â”‚       â”‚   â”œâ”€â”€ NotificationService.ts
â”‚   â”‚       â”‚   â””â”€â”€ UrlManager.ts
â”‚   â”‚       â”œâ”€â”€ types/
â”‚   â”‚       â”‚   â””â”€â”€ index.ts
â”‚   â”‚       â””â”€â”€ utils/
â”‚   â”‚           â”œâ”€â”€ ticketUtils.ts
â”‚   â”‚           â”œâ”€â”€ dateUtils.ts
â”‚   â”‚           â””â”€â”€ scrapingUtils.ts
â”‚   â””â”€â”€ config/
â”‚       â”œâ”€â”€ scrapingConfig.ts
â”‚       â”œâ”€â”€ urlConfig.ts
â”‚       â””â”€â”€ environments/
â”œâ”€â”€ supabase/
â”‚   â”œâ”€â”€ functions/
â”‚   â”‚   â”œâ”€â”€ daily-check/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ notification-check/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ _shared/
â”‚   â”‚       â””â”€â”€ import_map.json
â”‚   â”œâ”€â”€ migrations/
â”‚   â”‚   â”œâ”€â”€ 001_initial_schema.sql
â”‚   â”‚   â””â”€â”€ 002_cron_jobs.sql
â”‚   â””â”€â”€ config.toml
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ config/
â”‚   â””â”€â”€ integration/
â”œâ”€â”€ docs/
â”‚   â””â”€â”€ README.md
â”œâ”€â”€ deno.json
â”œâ”€â”€ import_map.json
â””â”€â”€ .gitignore
```

## 2. å‹å®šç¾©

### 2.1 ãƒã‚±ãƒƒãƒˆé–¢é€£å‹

```typescript
// src/features/shared/types/Ticket.ts
export interface Ticket {
  id: string;
  matchName: string;
  matchDate: Date;
  homeTeam: string;
  awayTeam: string;
  saleStartDate: Date;
  saleStartTime?: string;
  venue: string;
  ticketTypes: string[];
  ticketUrl: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface ScrapedTicketData {
  matchName: string;
  matchDate: string;
  saleDate: string;
  ticketTypes: string[];
  ticketUrl: string;
  venue: string;
}
```

### 2.2 é€šçŸ¥é–¢é€£å‹

```typescript
// src/features/shared/types/NotificationHistory.ts
export interface NotificationHistory {
  id: string;
  ticketId: string;
  notificationType: 'day_before' | 'hour_before' | 'minutes_before';
  scheduledAt
```
