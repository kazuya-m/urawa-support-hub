### 2.2 実装済みドメインエンティティ

```typescript
// src/domain/entities/NotificationHistory.ts
export class NotificationHistory {
  constructor(private props: NotificationHistoryProps) {
    this.validateNotificationHistory(props);
  }

  // ビジネスロジック
  canSend(): boolean;
  isExpired(): boolean;  
  canRetry(): boolean;
  markAsSent(): void;
  markAsFailed(errorMessage: string): void;
  
  // バリデーション
  private validateNotificationHistory(props: NotificationHistoryProps): void;
}

// 設定駆動通知タイミング
export const NOTIFICATION_TIMING_CONFIG = {
  day_before: {
    displayName: '販売開始前日',
    calculateScheduledTime: (saleStartDate: Date) => Date,
    toleranceMs: 5 * 60 * 1000
  }
} as const;
```

## 3. 実装済みリポジトリ層

### 3.1 ドメインインターフェース

```typescript
// src/domain/interfaces/TicketRepository.ts
export interface TicketRepository {
  save(ticket: Ticket): Promise<void>;
  findById(id: string): Promise<Ticket | null>;
  findAll(): Promise<Ticket[]>;
  findByDateRange(startDate: Date, endDate: Date): Promise<Ticket[]>;
  update(ticket: Ticket): Promise<void>;
  delete(id: string): Promise<void>;
}

// src/domain/interfaces/NotificationRepository.ts  
export interface NotificationRepository {
  save(notification: NotificationHistory): Promise<void>;
  findById(id: string): Promise<NotificationHistory | null>;
  findByTicketId(ticketId: string): Promise<NotificationHistory[]>;
  update(notification: NotificationHistory): Promise<void>;
}
```

### 3.2 インフラストラクチャ実装

```typescript
// src/infrastructure/repositories/TicketRepositoryImpl.ts
export class TicketRepositoryImpl implements TicketRepository {
  constructor(private supabase: SupabaseClient) {}
  
  async save(ticket: Ticket): Promise<void> {
    const data = TicketConverter.toDatabase(ticket);
    const { error } = await this.supabase.from('tickets').insert(data);
    if (error) handleSupabaseError('save ticket', error);
  }
}
```

### 3.3 実装済みテスト

```typescript
// tests/integration/repository.test.ts - 統合テスト
Deno.test('TicketRepository - save and findById', async () => {
  const ticket = new Ticket({...});
  await ticketRepo.save(ticket);
  const found = await ticketRepo.findById(ticket.id);
  assertEquals(found?.id, ticket.id);
});

// src/domain/entities/__tests__/Ticket.test.ts - ユニットテスト  
Deno.test('Ticket - 正常なチケット作成', () => {
  const ticket = new Ticket({...});
  assertEquals(ticket.id, 'test-id');
});

// 45テスト実装済み（unit + integration）
import { TicketRepository } from '../../shared/repositories/TicketRepository.ts';

export class SupabaseTicketRepository implements TicketRepository {
  constructor(private supabase: SupabaseClient) {}

  async findFutureTickets(): Promise<Ticket[]> {
    const { data, error } = await this.supabase
      .from('tickets')
      .select('*')
      .gt('match_date', new Date().toISOString())
      .order('match_date', { ascending: true });

    if (error) throw new Error(`Failed to fetch future tickets: ${error.message}`);
    return data.map(this.mapToTicket);
  }

  async save(ticket: Ticket): Promise<void> {
    const { error } = await this.supabase
      .from('tickets')
      .insert(this.mapToDatabase(ticket));

    if (error) throw new Error(`Failed to save ticket: ${error.message}`);
  }

  async update(ticket: Ticket): Promise<void> {
    const { error } = await this.supabase
      .from('tickets')
      .update({ ...this.mapToDatabase(ticket), updated_at: new Date().toISOString() })
      .eq('id', ticket.id);

    if (error) throw new Error(`Failed to update ticket: ${error.message}`);
  }

  private mapToTicket(data: any): Ticket {
    return {
      id: data.id,
      matchName: data.match_name,
      matchDate: new Date(data.match_date),
      homeTeam: data.home_team,
      awayTeam: data.away_team,
      saleStartDate: new Date(data.sale_start_date),
      saleStartTime: data.sale_start_time,
      venue: data.venue,
      ticketTypes: data.ticket_types,
      ticketUrl: data.ticket_url,
      createdAt: new Date(data.created_at),
      updatedAt: new Date(data.updated_at),
    };
  }

  private mapToDatabase(ticket: Ticket): any {
    return {
      id: ticket.id,
      match_name: ticket.matchName,
      match_date: ticket.matchDate.toISOString(),
      home_team: ticket.homeTeam,
      away_team: ticket.awayTeam,
      sale_start_date: ticket.saleStartDate.toISOString(),
      sale_start_time: ticket.saleStartTime,
      venue: ticket.venue,
      ticket_types: ticket.ticketTypes,
      ticket_url: ticket.ticketUrl,
    };
  }
}
```

## 4. URL管理システム

### 4.1 URL設定インターフェース

```typescript
// src/config/urlConfig.ts
export interface UrlConfig {
  readonly staticUrls: {
    readonly jleagueTicketBase: string;
    readonly urawaClubPage: string;
    readonly lineApiBase: string;
    readonly sitemapUrl: string;
  };
  dynamicUrls: {
    urawaAwayTabUrl: string;
    fallbackUrls: string[];
  };
  environmentUrls: {
    webhookUrl?: string;
    debugUrl?: string;
  };
}
```

### 4.2 UrlManager実装

```typescript
// src/services/UrlManager.ts
export class UrlManager {
  private static instance: UrlManager;
  private config: UrlConfig;

  private constructor() {
    this.config = {
      staticUrls: {
        jleagueTicketBase: 'https://www.jleague-ticket.jp',
        urawaClubPage: 'https://www.jleague-ticket.jp/club/ur/',
        lineApiBase: 'https://api.line.me/v2/bot',
        sitemapUrl: 'https://www.jleague-ticket.jp/sitemap.xml',
      },
      dynamicUrls: {
        urawaAwayTabUrl: Deno.env.get('URAWA_AWAY_TAB_URL') ||
          'https://www.jleague-ticket.jp/club/ur/?tab=away',
        fallbackUrls: [
          'https://www.jleague-ticket.jp/club/ur/#away',
          'https://www.jleague-ticket.jp/club/ur/away/',
          'https://www.jleague-ticket.jp/club/ur/?view=away',
        ],
      },
      environmentUrls: {
        webhookUrl: Deno.env.get('WEBHOOK_URL'),
        debugUrl: Deno.env.get('DEBUG_URL'),
      },
    };
  }

  public static getInstance(): UrlManager {
    if (!UrlManager.instance) {
      UrlManager.instance = new UrlManager();
    }
    return UrlManager.instance;
  }

  getStaticUrl(key: keyof typeof this.config.staticUrls): string {
    return this.config.staticUrls[key];
  }

  getDynamicUrl(key: keyof typeof this.config.dynamicUrls): string {
    return this.config.dynamicUrls[key];
  }

  getUrlWithFallbacks(): string[] {
    const primary = this.getDynamicUrl('urawaAwayTabUrl');
    const fallbacks = this.config.dynamicUrls.fallbackUrls;
    return [primary, ...fallbacks];
  }
}
```

## 5. スクレイピングサービス実装

### 5.1 スクレイピング設定

```typescript
// src/config/scrapingConfig.ts
export interface ScrapingConfig {
  awayTabSelectors: string[];
  selectors: {
    ticketContainer: string[];
    matchTitle: string[];
    matchDate: string[];
    saleDate: string[];
    ticketType: string[];
    venue: string[];
    ticketLink: string[];
  };
  awayKeywords: string[];
  generalSaleKeyword: string;
  timeouts: {
    pageLoad: number;
    elementWait: number;
    tabSwitch: number;
  };
}

export const optimizedScrapingConfig: ScrapingConfig = {
  awayTabSelectors: [
    '[data-tab="away"]',
    '.tab-away',
    '.away-tab',
    'a[href*="away"]',
    'button[data-target*="away"]',
    '.nav-away',
    '#away-tab',
  ],
  selectors: {
    ticketContainer: [
      '.ticket-item',
      '.match-item',
      '.game-item',
      '.event-item',
      '.item',
      '.card',
    ],
    matchTitle: [
      '.match-title',
      '.game-title',
      '.match-name',
      '.event-title',
      'h3',
      'h4',
      '.title',
    ],
    matchDate: [
      '.match-date',
      '.game-date',
      '.date',
      '.datetime',
      'time',
      '.schedule',
    ],
    saleDate: [
      '.sale-date',
      '.ticket-sale',
      '.sale-info',
      '.sale',
      '.ticket-info',
      '.info',
    ],
    ticketType: [
      '.ticket-type',
      '.seat-type',
      '.ticket-category',
      '.type',
      '.category',
    ],
    venue: [
      '.venue',
      '.stadium',
      '.location',
      '.place',
    ],
    ticketLink: [
      'a',
      '.ticket-link',
      '.buy-link',
      '.purchase-link',
    ],
  },
  awayKeywords: ['ビジター', 'ミックス', 'アウェイ', 'バックアウェイ', 'メインアウェイ'],
  generalSaleKeyword: '一般販売',
  timeouts: {
    pageLoad: 30000,
    elementWait: 10000,
    tabSwitch: 2000,
  },
};
```

### 5.2 AWAYタブスクレイピングサービス

```typescript
// src/features/away-tickets/services/AwayTabScrapingService.ts
import { chromium } from 'playwright';
import { UrlManager } from '../../shared/services/UrlManager.ts';

export class AwayTabScrapingService {
  private urlManager: UrlManager;

  constructor(private config: ScrapingConfig) {
    this.urlManager = UrlManager.getInstance();
  }

  async scrapeTickets(): Promise<
    { success: boolean; tickets: ScrapedTicketData[]; errors: string[] }
  > {
    let browser = null;
    try {
      browser = await chromium.launch({ headless: true });
      const page = await browser.newPage();

      // メインページアクセス
      const mainPageUrl = this.urlManager.getStaticUrl('urawaClubPage');
      await page.goto(mainPageUrl, { waitUntil: 'networkidle' });

      // AWAYタブアクセス（フォールバック対応）
      const tickets = await this.scrapeAwayTabWithFallback(page);

      return {
        success: true,
        tickets,
        errors: [],
      };
    } catch (error) {
      return {
        success: false,
        tickets: [],
        errors: [error.message],
      };
    } finally {
      if (browser) await browser.close();
    }
  }

  private async scrapeAwayTabWithFallback(page: any): Promise<ScrapedTicketData[]> {
    const awayUrls = this.urlManager.getUrlWithFallbacks();

    for (const url of awayUrls) {
      try {
        console.log(`Trying away tab URL: ${url}`);

        if (url.includes('?tab=away') || url.includes('#away')) {
          await page.goto(url, { waitUntil: 'networkidle', timeout: 15000 });
        } else {
          await this.clickAwayTab(page);
        }

        const tickets = await this.extractAwayTickets(page);
        if (tickets.length > 0) {
          console.log(`Success with URL: ${url}, found ${tickets.length} tickets`);
          return tickets;
        }
      } catch (error) {
        console.log(`Failed with URL: ${url}, error: ${error.message}`);
        continue;
      }
    }

    throw new Error('All away tab access methods failed');
  }

  private async clickAwayTab(page: any): Promise<void> {
    for (const selector of this.config.awayTabSelectors) {
      try {
        const element = await page.$(selector);
        if (element) {
          await element.click();
          await page.waitForTimeout(this.config.timeouts.tabSwitch);
          return;
        }
      } catch (error) {
        continue;
      }
    }
    throw new Error('Away tab not found');
  }

  private async extractAwayTickets(page: any): Promise<ScrapedTicketData[]> {
    await page.waitForSelector(this.config.selectors.ticketContainer[0], {
      timeout: this.config.timeouts.elementWait,
    });

    const ticketElements = await page.$eval(
      this.config.selectors.ticketContainer.join(','),
      (elements, selectors) => {
        return elements.map((el) => ({
          matchName: this.getTextBySelectors(el, selectors.matchTitle) || '',
          matchDate: this.getTextBySelectors(el, selectors.matchDate) || '',
          saleDate: this.getTextBySelectors(el, selectors.saleDate) || '',
          ticketTypes: this.getTextArrayBySelectors(el, selectors.ticketType),
          venue: this.getTextBySelectors(el, selectors.venue) || '',
          ticketUrl: this.getHrefBySelectors(el, selectors.ticketLink) || '',
        }));
      },
      this.config.selectors,
    );

    return ticketElements.filter((ticket) => this.isValidAwayTicket(ticket));
  }

  private isValidAwayTicket(ticket: ScrapedTicketData): boolean {
    if (!ticket.matchName || !ticket.saleDate) return false;

    // アウェイ戦の特徴確認
    const hasAwayIndicator = !ticket.venue.includes('埼玉スタジアム') ||
      /(.+)\s*(vs|対)\s*浦和レッズ/.test(ticket.matchName);

    // アウェイ向けチケット種別確認
    const hasAwayTicketType = ticket.ticketTypes.some((type) =>
      this.config.awayKeywords.some((keyword) => type.includes(keyword))
    );

    // 一般販売確認
    const isGeneralSale = ticket.ticketTypes.some((type) =>
      type.includes(this.config.generalSaleKeyword)
    );

    return hasAwayIndicator && hasAwayTicketType && isGeneralSale;
  }
}
```

## 6. 通知サービス実装

### 6.1 NotificationServiceインターフェース

```typescript
// src/features/shared/services/NotificationService.ts
export interface NotificationService {
  sendNotification(message: NotificationMessage): Promise<{ success: boolean; error?: string }>;
}
```

### 6.2 LINE通知サービス実装

```typescript
// src/features/away-tickets/services/LineNotificationService.ts
export class LineNotificationService implements NotificationService {
  constructor(
    private channelAccessToken: string,
    private groupChatId: string,
  ) {}

  async sendNotification(
    message: NotificationMessage,
  ): Promise<{ success: boolean; error?: string }> {
    try {
      const response = await fetch('https://api.line.me/v2/bot/message/push', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.channelAccessToken}`,
        },
        body: JSON.stringify({
          to: this.groupChatId,
          messages: [{ type: 'text', text: message.content }],
        }),
      });

      if (!response.ok) {
        const error = await response.text();
        return { success: false, error: `LINE API Error: ${response.status} - ${error}` };
      }

      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
}
```

## 7. ユーティリティ関数

### 7.1 チケット関連ユーティリティ

```typescript
// src/features/shared/utils/ticketUtils.ts
export function generateTicketId(matchName: string, matchDate: Date): string {
  const dateStr = matchDate.toISOString().split('T')[0];
  const input = `${matchName}-${dateStr}`;

  // 簡易ハッシュ関数（Deno環境対応）
  let hash = 0;
  for (let i = 0; i < input.length; i++) {
    const char = input.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // 32bit整数に変換
  }
  return Math.abs(hash).toString(36).substring(0, 16);
}

export function parseScrapedTicket(scraped: ScrapedTicketData): Ticket {
  const matchDate = parseDateString(scraped.matchDate);
  const saleStartDate = parseDateString(scraped.saleDate);
  const [homeTeam, awayTeam] = parseTeamNames(scraped.matchName);

  return {
    id: generateTicketId(scraped.matchName, matchDate),
    matchName: scraped.matchName,
    matchDate,
    homeTeam,
    awayTeam,
    saleStartDate,
    venue: scraped.venue,
    ticketTypes: scraped.ticketTypes,
    ticketUrl: scraped.ticketUrl,
    createdAt: new Date(),
    updatedAt: new Date(),
  };
}

export function parseDateString(dateStr: string): Date {
  const patterns = [
    /(\d{4})年(\d{1,2})月(\d{1,2})日\s*(\d{1,2}):(\d{2})/,
    /(\d{4})\/(\d{1,2})\/(\d{1,2})\s*(\d{1,2}):(\d{2})/,
    /(\d{1,2})\/(\d{1,2})\s*(\d{1,2}):(\d{2})/,
    /(\d{1,2})月(\d{1,2})日\s*(\d{1,2}):(\d{2})/,
  ];

  for (const pattern of patterns) {
    const match = dateStr.match(pattern);
    if (match) {
      const currentYear = new Date().getFullYear();
      let [, year, month, day, hour, minute] = match;

      if (pattern.source.includes('\\d{1,2}月') || pattern.source.includes('\\d{1,2}\\/')) {
        year = currentYear.toString();
      }

      const parsedDate = new Date(
        parseInt(year),
        parseInt(month) - 1,
        parseInt(day),
        parseInt(hour),
        parseInt(minute),
      );

      if (parsedDate < new Date() && !year) {
        parsedDate.setFullYear(currentYear + 1);
      }

      return parsedDate;
    }
  }

  throw new Error(`Cannot parse date string: ${dateStr}`);
}

export function createNotificationMessage(ticket: Ticket, type: string): string {
  const typeEmoji = {
    'day_before': '📅',
    'hour_before': '⏰',
    'minutes_before': '🚨',
  };

  const typeText = {
    'day_before': '販売開始前日',
    'hour_before': '販売開始1時間前',
    'minutes_before': '販売開始15分前',
  };

  return `${typeEmoji[type] || '🏟️'} 浦和レッズ アウェイ戦チケット販売のお知らせ

📍 ${typeText[type] || type}通知

🏟️ 試合: ${ticket.matchName}
📅 試合日: ${ticket.matchDate.toLocaleDateString('ja-JP')} ${
    ticket.matchDate.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' })
  }
🎫 販売開始: ${ticket.saleStartDate.toLocaleDateString('ja-JP')} ${
    ticket.saleStartDate.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' })
  }
🏟️ 会場: ${ticket.venue}

🎫 チケット購入はこちら:
${ticket.ticketUrl}

#浦和レッズ #アウェイ戦 #${type}`;
}
```

## 8. Edge Functions実装

### 8.1 daily-check Function

```typescript
// supabase/functions/daily-check/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from '@supabase/supabase-js';
import { SupabaseTicketRepository } from '../../../src/features/away-tickets/repositories/SupabaseTicketRepository.ts';
import { AwayTabScrapingService } from '../../../src/features/away-tickets/services/AwayTabScrapingService.ts';
import { LineNotificationService } from '../../../src/features/away-tickets/services/LineNotificationService.ts';
import { optimizedScrapingConfig } from '../../../src/config/scrapingConfig.ts';
import { parseScrapedTicket } from '../../../src/features/shared/utils/ticketUtils.ts';

serve(async (req: Request) => {
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'POST',
    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  };

  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    // シーズンオフチェック（12月スキップ）
    const currentMonth = new Date().getMonth() + 1;
    if (currentMonth === 12) {
      return new Response(
        JSON.stringify({
          message: 'シーズンオフのためスキップしました',
          month: currentMonth,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        },
      );
    }

    // 依存関係初期化
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
    );

    const ticketRepo = new SupabaseTicketRepository(supabase);
    const scrapingService = new AwayTabScrapingService(optimizedScrapingConfig);
    const notificationService = new LineNotificationService(
      Deno.env.get('LINE_CHANNEL_ACCESS_TOKEN')!,
      Deno.env.get('LINE_GROUP_CHAT_ID')!,
    );

    // AWAYタブスクレイピング実行
    console.log('Starting away tab scraping...');
    const scrapingResult = await scrapingService.scrapeTickets();

    if (!scrapingResult.success) {
      await notificationService.sendNotification({
        content: `❌ アウェイチケット情報の取得に失敗しました\n\nエラー:\n${
          scrapingResult.errors.join('\n')
        }`,
        type: 'error',
      });

      return new Response(
        JSON.stringify({
          success: false,
          errors: scrapingResult.errors,
        }),
        {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        },
      );
    }

    // 既存データとの比較・更新処理
    console.log(`Found ${scrapingResult.tickets.length} away tickets`);
    const existingTickets = await ticketRepo.findFutureTickets();

    let newCount = 0;
    let updateCount = 0;
    const processedTickets: string[] = [];

    for (const scrapedData of scrapingResult.tickets) {
      try {
        const ticket = parseScrapedTicket(scrapedData);
        const existing = await ticketRepo.findById(ticket.id);

        if (!existing) {
          await ticketRepo.save(ticket);
          newCount++;
          processedTickets.push(`新規: ${ticket.matchName}`);
          console.log(`新規チケット保存: ${ticket.matchName}`);
        } else if (existing.saleStartDate.getTime() !== ticket.saleStartDate.getTime()) {
          await ticketRepo.update(ticket);
          updateCount++;
          processedTickets.push(`更新: ${ticket.matchName}`);
          console.log(`チケット更新: ${ticket.matchName}`);
        }
      } catch (error) {
        console.error('チケット処理エラー:', error);
        processedTickets.push(`エラー: ${scrapedData.matchName} - ${error.message}`);
      }
    }

    // 古いデータのクリーンアップ
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
    await ticketRepo.deleteExpired(oneWeekAgo);

    // 処理結果の通知（新規・更新がある場合のみ）
    if (newCount > 0 || updateCount > 0) {
      await notificationService.sendNotification({
        content:
          `🔄 アウェイチケット情報を更新しました\n\n新規: ${newCount}件\n更新: ${updateCount}件\n\n詳細:\n${
            processedTickets.join('\n')
          }`,
        type: 'update',
      });
    }

    return new Response(
      JSON.stringify({
        success: true,
        newTickets: newCount,
        updatedTickets: updateCount,
        totalScraped: scrapingResult.tickets.length,
        processedTickets,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      },
    );
  } catch (error) {
    console.error('Daily check error:', error);
    return new Response(
      JSON.stringify({
        error: 'Internal server error',
        message: error.message,
        timestamp: new Date().toISOString(),
      }),
      {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      },
    );
  }
});
```

## 9. データベーススキーマ

### 9.1 基本スキーマ

```sql
-- supabase/migrations/001_initial_schema.sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- チケット情報テーブル
CREATE TABLE tickets (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  match_name TEXT NOT NULL,
  match_date TIMESTAMPTZ NOT NULL,
  home_team TEXT NOT NULL,
  away_team TEXT NOT NULL,
  sale_start_date TIMESTAMPTZ NOT NULL,
  sale_start_time TEXT,
  venue TEXT NOT NULL,
  ticket_types TEXT[] NOT NULL,
  ticket_url TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- 制約
  CONSTRAINT match_date_future CHECK (match_date > created_at),
  CONSTRAINT sale_date_valid CHECK (sale_start_date > created_at),
  CONSTRAINT ticket_types_not_empty CHECK (array_length(ticket_types, 1) > 0),
  CONSTRAINT valid_url CHECK (ticket_url LIKE 'http%')
);

-- 通知履歴テーブル
CREATE TABLE notification_history (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  ticket_id UUID REFERENCES tickets(id) ON DELETE CASCADE,
  notification_type TEXT NOT NULL CHECK (
    notification_type IN ('day_before', 'hour_before', 'minutes_before')
  ),
  scheduled_at TIMESTAMPTZ NOT NULL,
  sent_at TIMESTAMPTZ,
  status TEXT NOT NULL DEFAULT 'pending' CHECK (
    status IN ('pending', 'sent', 'failed')
  ),
  error_message TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- 重複防止制約
  UNIQUE(ticket_id, notification_type)
);

-- インデックス作成
CREATE INDEX idx_tickets_match_date ON tickets(match_date);
CREATE INDEX idx_tickets_sale_start_date ON tickets(sale_start_date);
CREATE INDEX idx_notification_history_scheduled_at ON notification_history(scheduled_at);
CREATE INDEX idx_notification_history_status ON notification_history(status);

-- RLS有効化
ALTER TABLE tickets ENABLE ROW LEVEL SECURITY;
ALTER TABLE notification_history ENABLE ROW LEVEL SECURITY;

-- Service Role用ポリシー
CREATE POLICY "Service role full access tickets" ON tickets
  FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');

CREATE POLICY "Service role full access notifications" ON notification_history
  FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');
```

### 9.2 Cronジョブ設定

```sql
-- supabase/migrations/002_cron_jobs.sql
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- 毎日12:00 JST (03:00 UTC) でチケットチェック
SELECT cron.schedule(
  'daily-ticket-check',
  '0 3 * * *',
  $
  SELECT net.http_post(
    url := current_setting('app.base_url') || '/functions/v1/daily-check',
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || current_setting('app.service_role_key')
    ),
    body := jsonb_build_object('source', 'cron')
  ) as request_id;
  $
);

-- 5分間隔で通知チェック
SELECT cron.schedule(
  'notification-check',
  '*/5 * * * *',
  $
  SELECT net.http_post(
    url := current_setting('app.base_url') || '/functions/v1/notification-check',
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || current_setting('app.service_role_key')
    ),
    body := jsonb_build_object('source', 'cron')
  ) as request_id;
  $
);
```

## 10. テスト設計

### 10.1 単体テスト例

````typescript
// tests/features/shared/utils/ticketUtils.test.ts
import { assertEquals, assertThrows } from "std/testing/asserts.ts";
import { generateTicketId, parseDateString } from "@/features/shared/utils/ticketUtils.ts";

## 10. テスト設計

### 10.1 単体テスト例
```typescript
// tests/features/shared/utils/ticketUtils.test.ts
import { assertEquals, assertThrows } from "std/testing/asserts.ts";
import { generateTicketId, parseDateString } from "@/features/shared/utils/ticketUtils.ts";

Deno.test("generateTicketId - should create consistent ID for same input", () => {
  const matchName = "FC東京 vs 浦和レッズ";
  const matchDate = new Date('2024-03-15T19:30:00+09:00');
  
  const id1 = generateTicketId(matchName, matchDate);
  const id2 = generateTicketId(matchName, matchDate);
  
  assertEquals(id1, id2);
  assertEquals(typeof id1, 'string');
  assertEquals(id1.length, 16);
});

Deno.test("parseDateString - should handle multiple date formats", () => {
  const testCases = [
    { input: "2024年3月15日 19:30", expected: new Date(2024, 2, 15, 19, 30) },
    { input: "2024/03/15 19:30", expected: new Date(2024, 2, 15, 19, 30) },
    { input: "3/15 19:30", expected: new Date(new Date().getFullYear(), 2, 15, 19, 30) }
  ];
  
  testCases.forEach(({ input, expected }) => {
    const result = parseDateString(input);
    assertEquals(result.getFullYear(), expected.getFullYear());
    assertEquals(result.getMonth(), expected.getMonth());
    assertEquals(result.getDate(), expected.getDate());
    assertEquals(result.getHours(), expected.getHours());
    assertEquals(result.getMinutes(), expected.getMinutes());
  });
});

Deno.test("parseDateString - should throw error for invalid format", () => {
  assertThrows(
    () => parseDateString("invalid date"),
    Error,
    "Cannot parse date string"
  );
});
````

### 10.2 統合テスト例

```typescript
// tests/integration/TicketRepository.test.ts
import { assert, assertEquals } from 'std/testing/asserts.ts';
import { createClient } from '@supabase/supabase-js';
import { SupabaseTicketRepository } from '@/features/away-tickets/repositories/SupabaseTicketRepository.ts';

Deno.test('SupabaseTicketRepository - CRUD operations', async () => {
  const supabase = createClient(
    Deno.env.get('SUPABASE_URL')!,
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
  );

  const repository = new SupabaseTicketRepository(supabase);

  // テストデータ作成
  const testTicket = {
    id: 'test-ticket-id',
    matchName: 'テスト試合 vs 浦和レッズ',
    matchDate: new Date('2025-03-15T19:30:00+09:00'),
    homeTeam: 'テストチーム',
    awayTeam: '浦和レッズ',
    saleStartDate: new Date('2025-03-01T10:00:00+09:00'),
    venue: 'テストスタジアム',
    ticketTypes: ['ビジター席', '一般販売'],
    ticketUrl: 'https://example.com/test-ticket',
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  try {
    // 保存テスト
    await repository.save(testTicket);

    // 取得テスト
    const savedTicket = await repository.findById(testTicket.id);
    assert(savedTicket !== null);
    assertEquals(savedTicket.matchName, testTicket.matchName);

    // 更新テスト
    testTicket.matchName = '更新済み試合名';
    await repository.update(testTicket);

    const updatedTicket = await repository.findById(testTicket.id);
    assertEquals(updatedTicket?.matchName, '更新済み試合名');
  } finally {
    // クリーンアップ
    await supabase.from('tickets').delete().eq('id', testTicket.id);
  }
});
```

## 11. 設定ファイル

### 11.1 Deno設定

```json
// deno.json
{
  "compilerOptions": {
    "allowJs": true,
    "lib": ["deno.window"],
    "strict": true,
    "noImplicitAny": true,
    "noImplicitReturns": true
  },
  "importMap": "./import_map.json",
  "tasks": {
    "start": "supabase start",
    "dev": "supabase functions serve --debug",
    "test": "deno test --allow-all --coverage=coverage",
    "deploy": "supabase functions deploy",
    "db:reset": "supabase db reset",
    "db:push": "supabase db push",
    "lint": "deno lint",
    "fmt": "deno fmt"
  },
  "lint": {
    "files": {
      "include": ["src/", "supabase/functions/"],
      "exclude": ["supabase/functions/_shared/"]
    }
  },
  "fmt": {
    "options": {
      "useTabs": false,
      "lineWidth": 100,
      "indentWidth": 2,
      "singleQuote": true
    }
  }
}
```

### 11.2 Import Map

```json
// import_map.json
{
  "imports": {
    "@supabase/supabase-js": "https://esm.sh/@supabase/supabase-js@2",
    "playwright": "https://deno.land/x/playwright@0.4.0/mod.ts",
    "std/": "https://deno.land/std@0.208.0/",
    "@/": "./src/",
    "date-fns": "https://esm.sh/date-fns@2.30.0",
    "testing/": "https://deno.land/std@0.208.0/testing/"
  }
}
```

## 12. エラーハンドリング設計

### 12.1 エラー分類

```typescript
// src/features/shared/errors/CustomErrors.ts
export class ScrapingError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = 'ScrapingError';
  }
}

export class DatabaseError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = 'DatabaseError';
  }
}

export class NotificationError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = 'NotificationError';
  }
}
```

### 12.2 エラーハンドリング戦略

```typescript
// src/features/shared/utils/errorHandler.ts
export class ErrorHandler {
  static async handleScrapingError(
    error: Error,
    notificationService: NotificationService,
  ): Promise<void> {
    console.error('Scraping error:', error);

    await notificationService.sendNotification({
      content: `🚨 スクレイピングエラー\n\n${error.message}\n\n時刻: ${
        new Date().toLocaleString('ja-JP')
      }`,
      type: 'error',
    });
  }

  static async handleDatabaseError(
    error: Error,
    notificationService: NotificationService,
  ): Promise<void> {
    console.error('Database error:', error);

    await notificationService.sendNotification({
      content: `💾 データベースエラー\n\n${error.message}\n\n時刻: ${
        new Date().toLocaleString('ja-JP')
      }`,
      type: 'error',
    });
  }

  static async handleNotificationError(error: Error): Promise<void> {
    console.error('Notification error:', error);
    // 通知エラーの場合はログ出力のみ（無限ループ防止）
  }
}
```

## 13. パフォーマンス最適化設計

### 13.1 メモリ最適化

```typescript
// src/features/shared/utils/performanceUtils.ts
export class PerformanceOptimizer {
  static async withMemoryMonitoring<T>(operation: () => Promise<T>, label: string): Promise<T> {
    const memBefore = Deno.memoryUsage();
    console.log(`[${label}] Memory before: ${Math.round(memBefore.heapUsed / 1024 / 1024)}MB`);

    try {
      const result = await operation();

      const memAfter = Deno.memoryUsage();
      console.log(`[${label}] Memory after: ${Math.round(memAfter.heapUsed / 1024 / 1024)}MB`);
      console.log(
        `[${label}] Memory diff: ${
          Math.round((memAfter.heapUsed - memBefore.heapUsed) / 1024 / 1024)
        }MB`,
      );

      return result;
    } catch (error) {
      const memError = Deno.memoryUsage();
      console.log(`[${label}] Memory on error: ${Math.round(memError.heapUsed / 1024 / 1024)}MB`);
      throw error;
    }
  }

  static async withTimeout<T>(
    operation: () => Promise<T>,
    timeoutMs: number,
    label: string,
  ): Promise<T> {
    const timeoutPromise = new Promise<never>((_, reject) => {
      setTimeout(() => reject(new Error(`${label} timed out after ${timeoutMs}ms`)), timeoutMs);
    });

    return Promise.race([operation(), timeoutPromise]);
  }
}
```

### 13.2 データベース最適化

```sql
-- データベースクエリ最適化のための追加インデックス
CREATE INDEX CONCURRENTLY idx_tickets_composite ON tickets(away_team, match_date) 
WHERE away_team = '浦和レッズ';

CREATE INDEX CONCURRENTLY idx_notification_pending ON notification_history(scheduled_at) 
WHERE status = 'pending';

-- 統計情報の定期更新
CREATE OR REPLACE FUNCTION update_table_statistics()
RETURNS void AS $
BEGIN
  ANALYZE tickets;
  ANALYZE notification_history;
END;
$ LANGUAGE plpgsql;
```

## 14. セキュリティ設計

### 14.1 入力値検証

```typescript
// src/features/shared/utils/validation.ts
export class InputValidator {
  static validateTicketUrl(url: string): boolean {
    try {
      const parsedUrl = new URL(url);
      return parsedUrl.protocol === 'https:' &&
        parsedUrl.hostname.includes('jleague-ticket.jp');
    } catch {
      return false;
    }
  }

  static sanitizeMatchName(matchName: string): string {
    return matchName.replace(/[<>\"'&]/g, '').trim().substring(0, 255);
  }

  static validateDateRange(date: Date): boolean {
    const now = new Date();
    const maxFuture = new Date();
    maxFuture.setFullYear(now.getFullYear() + 1);

    return date > now && date < maxFuture;
  }
}
```

### 14.2 アクセス制御

```sql
-- より厳密なRLSポリシー
DROP POLICY IF EXISTS "Service role full access tickets" ON tickets;
CREATE POLICY "Service role tickets access" ON tickets
  FOR ALL 
  USING (auth.jwt() ->> 'role' = 'service_role')
  WITH CHECK (auth.jwt() ->> 'role' = 'service_role');

-- 読み取り専用ビューの作成（将来の管理画面用）
CREATE VIEW public_tickets AS
SELECT 
  match_name,
  match_date,
  venue,
  sale_start_date,
  array_length(ticket_types, 1) as ticket_type_count
FROM tickets
WHERE match_date > NOW()
ORDER BY match_date;
```

## 15. 監視・ログ設計

### 15.1 構造化ログ

```typescript
// src/features/shared/utils/logger.ts
export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
}

export class Logger {
  private static level: LogLevel = LogLevel.INFO;

  static setLevel(level: LogLevel) {
    this.level = level;
  }

  static debug(message: string, data?: any) {
    if (this.level <= LogLevel.DEBUG) {
      this.log('DEBUG', message, data);
    }
  }

  static info(message: string, data?: any) {
    if (this.level <= LogLevel.INFO) {
      this.log('INFO', message, data);
    }
  }

  static warn(message: string, data?: any) {
    if (this.level <= LogLevel.WARN) {
      this.log('WARN', message, data);
    }
  }

  static error(message: string, error?: Error, data?: any) {
    this.log('ERROR', message, { error: error?.message, stack: error?.stack, ...data });
  }

  private static log(level: string, message: string, data?: any) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      ...data,
    };

    console.log(JSON.stringify(logEntry));
  }
}
```

### 15.2 メトリクス収集

```typescript
// src/features/shared/utils/metrics.ts
export class Metrics {
  private static metrics: Map<string, number> = new Map();

  static increment(key: string, value: number = 1) {
    const current = this.metrics.get(key) || 0;
    this.metrics.set(key, current + value);
  }

  static set(key: string, value: number) {
    this.metrics.set(key, value);
  }

  static getAll(): Record<string, number> {
    return Object.fromEntries(this.metrics);
  }

  static async recordExecutionTime<T>(key: string, operation: () => Promise<T>): Promise<T> {
    const startTime = performance.now();
    try {
      const result = await operation();
      const duration = performance.now() - startTime;
      this.set(`${key}_duration_ms`, Math.round(duration));
      this.increment(`${key}_success_count`);
      return result;
    } catch (error) {
      const duration = performance.now() - startTime;
      this.set(`${key}_duration_ms`, Math.round(duration));
      this.increment(`${key}_error_count`);
      throw error;
    }
  }
}
```

## 16. デプロイメント設計

### 16.1 段階的デプロイメント

```bash
# デプロイメントスクリプト例
#!/bin/bash

# 環境変数チェック
if [ -z "$SUPABASE_PROJECT_ID" ]; then
  echo "Error: SUPABASE_PROJECT_ID is not set"
  exit 1
fi

# リンクチェック
supabase link --project-ref $SUPABASE_PROJECT_ID

# データベーススキーマのバリデーション
echo "Validating database schema..."
supabase db diff --schema public

# Edge Functionsのテスト
echo "Testing Edge Functions locally..."
deno test --allow-all

# 段階的デプロイ
echo "Deploying database migrations..."
supabase db push

echo "Deploying Edge Functions..."
supabase functions deploy daily-check --no-verify-jwt
supabase functions deploy notification-check --no-verify-jwt

echo "Deployment completed successfully!"
```

### 16.2 ロールバック戦略

```sql
-- ロールバック用のバックアップビュー作成
CREATE VIEW deployment_backup AS
SELECT 
  'tickets' as table_name,
  COUNT(*) as record_count,
  MAX(created_at) as latest_record,
  NOW() as backup_timestamp
FROM tickets
UNION ALL
SELECT 
  'notification_history' as table_name,
  COUNT(*) as record_count,
  MAX(created_at) as latest_record,
  NOW() as backup_timestamp
FROM notification_history;
```

## 17. Claude Code実装ガイド

### 17.1 実装の段階的進行

1. **Phase 1: 基盤構築**
   - Supabaseプロジェクト初期化
   - データベーススキーマ適用
   - 基本的な型定義作成

2. **Phase 2: リポジトリ層**
   - インターフェース定義
   - Supabase実装
   - 基本的なCRUD操作

3. **Phase 3: サービス層**
   - URL管理システム
   - スクレイピングサービス（実際のサイト調査後）
   - 通知サービス

4. **Phase 4: Edge Functions**
   - daily-check実装
   - notification-check実装
   - エラーハンドリング

5. **Phase 5: テスト・最適化**
   - 単体テスト
   - 統合テスト
   - パフォーマンス調整

### 17.2 実装時の注意点

- **サイト構造調査**: 実装前に必ずJリーグチケットサイトの詳細調査を実施
- **段階的テスト**: 各機能を個別にテストしてから統合
- **エラーハンドリング**: 外部API呼び出しは必ずtry-catch
- **ログ出力**: デバッグ情報の適切な出力
- **メモリ監視**: 512MB制限を意識した実装

この詳細設計書に従って実装することで、堅牢で保守性の高いシステムを構築できます。# urawa-support-hub
詳細設計書

## 1. プロジェクト構成

```
urawa-support-hub/
├── src/
│   ├── features/
│   │   ├── away-tickets/               # アウェイチケット監視機能
│   │   │   ├── repositories/
│   │   │   │   ├── SupabaseTicketRepository.ts
│   │   │   │   └── SupabaseNotificationRepository.ts
│   │   │   ├── services/
│   │   │   │   ├── AwayTabScrapingService.ts
│   │   │   │   └── LineNotificationService.ts
│   │   │   └── types/
│   │   │       ├── Ticket.ts
│   │   │       └── NotificationHistory.ts
│   │   ├── hotel-booking/              # Phase 2: ホテル予約リマインド
│   │   ├── home-tickets/               # Phase 2: ホームチケットアラート
│   │   └── shared/                     # 共通機能
│   │       ├── repositories/
│   │       │   ├── TicketRepository.ts
│   │       │   └── NotificationRepository.ts
│   │       ├── services/
│   │       │   ├── NotificationService.ts
│   │       │   └── UrlManager.ts
│   │       ├── types/
│   │       │   └── index.ts
│   │       └── utils/
│   │           ├── ticketUtils.ts
│   │           ├── dateUtils.ts
│   │           └── scrapingUtils.ts
│   └── config/
│       ├── scrapingConfig.ts
│       ├── urlConfig.ts
│       └── environments/
├── supabase/
│   ├── functions/
│   │   ├── daily-check/
│   │   │   └── index.ts
│   │   ├── notification-check/
│   │   │   └── index.ts
│   │   └── _shared/
│   │       └── import_map.json
│   ├── migrations/
│   │   ├── 001_initial_schema.sql
│   │   └── 002_cron_jobs.sql
│   └── config.toml
├── tests/
│   ├── features/
│   ├── config/
│   └── integration/
├── docs/
│   └── README.md
├── deno.json
├── import_map.json
└── .gitignore
```

## 2. 型定義

### 2.1 チケット関連型

```typescript
// src/features/shared/types/Ticket.ts
export interface Ticket {
  id: string;
  matchName: string;
  matchDate: Date;
  homeTeam: string;
  awayTeam: string;
  saleStartDate: Date;
  saleStartTime?: string;
  venue: string;
  ticketTypes: string[];
  ticketUrl: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface ScrapedTicketData {
  matchName: string;
  matchDate: string;
  saleDate: string;
  ticketTypes: string[];
  ticketUrl: string;
  venue: string;
}
```

### 2.2 通知関連型

```typescript
// src/features/shared/types/NotificationHistory.ts
export interface NotificationHistory {
  id: string;
  ticketId: string;
  notificationType: 'day_before' | 'hour_before' | 'minutes_before';
  scheduledAt
```
